name: Build and Publish APT Repository

on:
  push:
    branches: [ main ]
    paths:
      - '*.deb'
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils gnupg gzip curl

      - name: Detect .deb and package metadata
        id: detect
        run: |
          set -euo pipefail
          DEB_FILE=$(ls -1t *.deb 2>/dev/null | head -n1 || true)
          if [ -z "$DEB_FILE" ]; then
            echo "found_deb=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          PKG_NAME=$(dpkg-deb -f "$DEB_FILE" Package)
          PKG_VERSION=$(dpkg-deb -f "$DEB_FILE" Version)
          PKG_ARCH=$(dpkg-deb -f "$DEB_FILE" Architecture)
          echo "DEB_FILE=$DEB_FILE" >> $GITHUB_ENV
          echo "PKG_NAME=$PKG_NAME" >> $GITHUB_ENV
          echo "PKG_VERSION=$PKG_VERSION" >> $GITHUB_ENV
          echo "PKG_ARCH=$PKG_ARCH" >> $GITHUB_ENV
          echo "found_deb=true" >> $GITHUB_OUTPUT
        shell: bash

      - name: Import GPG private key and export public key
        if: steps.detect.outputs.found_deb == 'true'
        run: |
          set -euo pipefail
          export GNUPGHOME="$RUNNER_TEMP/gnupg"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"

          # Import private key from secret into this GNUPGHOME
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import --yes

          # Export public key for clients
          KEY_FPR=$(gpg --list-keys --with-colons | awk -F: '/^fpr:/ {print $10; exit}')
          mkdir -p repo
          gpg --armor --export "$KEY_FPR" > repo/public.key
          echo "Exported public key to repo/public.key (fingerprint: $KEY_FPR)"
        shell: bash

      - name: Build repo, index and sign
        if: steps.detect.outputs.found_deb == 'true'
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          export GNUPGHOME="$RUNNER_TEMP/gnupg"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"

          POOLDIR="repo/pool/main/${PKG_NAME}"
          DISTDIR_ARCH="repo/dists/stable/main/binary-${PKG_ARCH}"
          DISTDIR_AMD64="repo/dists/stable/main/binary-amd64"

          mkdir -p "$POOLDIR" "$DISTDIR_ARCH" "$DISTDIR_AMD64"

          # Copy the detected .deb into pool
          cp -v "$DEB_FILE" "$POOLDIR/"

          # Generate Packages.gz from the pool directory (ensures Filename: pool/...)
          dpkg-scanpackages repo/pool /dev/null | gzip -9c > "$DISTDIR_ARCH/Packages.gz"
          dpkg-scanpackages repo/pool /dev/null | gzip -9c > "$DISTDIR_AMD64/Packages.gz"

          # Create a minimal Release file
          printf '%s\n' \
            "Origin: SNAP-Connection-Manager" \
            "Label: SNAP Connection Manager" \
            "Suite: stable" \
            "Codename: stable" \
            "Architectures: amd64 all" \
            "Components: main" \
            "Description: SNAP Connection Manager APT repository" \
            > repo/dists/stable/Release

          # Sign the Release file (create InRelease and Release.gpg)
          GPG_OPTS="--batch --yes --pinentry-mode loopback --passphrase $GPG_PASSPHRASE"
          gpg $GPG_OPTS --clearsign -o repo/dists/stable/InRelease repo/dists/stable/Release
          gpg $GPG_OPTS -abs -o repo/dists/stable/Release.gpg repo/dists/stable/Release

          # Add a short release note included in Pages
          echo "- ${PKG_NAME} ${PKG_VERSION} ($(date -u +"%Y-%m-%d %H:%M UTC")): published" >> repo/RELEASES.md

          # Show a short listing for verification in the workflow log
          find repo -maxdepth 6 -type f -print
        shell: bash

      - name: Check if release tag exists
        if: steps.detect.outputs.found_deb == 'true'
        id: check_tag
        run: |
          set -euo pipefail
          TAG="v${{ env.PKG_VERSION }}"
          REPO="${{ github.repository }}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $TOKEN" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
          if [ "$STATUS" = "200" ]; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Create GitHub Release
        if: steps.check_tag.outputs.tag_exists == 'false' && steps.detect.outputs.found_deb == 'true'
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ env.PKG_VERSION }}
          release_name: ${{ env.PKG_NAME }} ${{ env.PKG_VERSION }}
          body: Automated release for ${{ env.PKG_NAME }} ${{ env.PKG_VERSION }}
          draft: false
          prerelease: false

      - name: Get existing release upload_url
        if: steps.check_tag.outputs.tag_exists == 'true' && steps.detect.outputs.found_deb == 'true'
        id: get_release
        run: |
          set -euo pipefail
          TAG="v${{ env.PKG_VERSION }}"
          REPO="${{ github.repository }}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"
          RESPONSE=$(curl -s -H "Authorization: token $TOKEN" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
          UPLOAD_URL=$(echo "$RESPONSE" | sed -n 's/.*"upload_url": *"\([^"]*\)".*/\1/p' | sed 's/{?name,label}//')
          echo "upload_url=$UPLOAD_URL" >> $GITHUB_OUTPUT
        shell: bash

      - name: Determine upload_url
        if: steps.detect.outputs.found_deb == 'true'
        id: determine_upload
        run: |
          set -euo pipefail
          # Prefer create_release output if present, otherwise use get_release output
          UPLOAD_FROM_CREATE="${{ steps.create_release.outputs.upload_url || '' }}"
          UPLOAD_FROM_GET="${{ steps.get_release.outputs.upload_url || '' }}"
          if [ -n "$UPLOAD_FROM_CREATE" ]; then
            echo "upload_url=$UPLOAD_FROM_CREATE" >> $GITHUB_OUTPUT
          elif [ -n "$UPLOAD_FROM_GET" ]; then
            echo "upload_url=$UPLOAD_FROM_GET" >> $GITHUB_OUTPUT
          else
            echo "upload_url=" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Debug upload_url
        if: steps.detect.outputs.found_deb == 'true'
        run: |
          echo "Resolved upload_url=${{ steps.determine_upload.outputs.upload_url }}"
        shell: bash

      - name: Upload .deb to GitHub Release
        if: steps.detect.outputs.found_deb == 'true'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.determine_upload.outputs.upload_url }}
          asset_path: repo/pool/main/${{ env.PKG_NAME }}/${{ env.DEB_FILE }}
          asset_name: ${{ env.DEB_FILE }}
          asset_content_type: application/vnd.debian.binary-package

      - name: Upload Pages Artifact
        if: steps.detect.outputs.found_deb == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: repo/

      - name: Deploy to GitHub Pages
        if: steps.detect.outputs.found_deb == 'true'
        uses: actions/deploy-pages@v4

